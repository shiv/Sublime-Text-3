<snippet>
	<content><![CDATA[
class graph{
public: 
	const ll INF = 1e18L + 5;
	ll n, e;
	vt<vt<ll>> g;
	vt<ll> bfs_dist, depth, dijkstra_dist;

	graph(ll _n){
		n = _n;
		g.resize(n + 1);
	}

	graph(ll _n, vt<vt<ll>> edge){
		n = _n;
		g = edge;
	}

	// undirected edge
	void uadd(ll u, ll v){
		g[u].pb(v);
		g[v].pb(u);
	}

    // directed edge
	void dadd(ll u, ll v){
		g[u].pb(v);
	}

	void bfs(vt<ll> src){
		bfs_dist.resize(n + 1, INF);
		queue<ll> q;
		for(ll ele: src){
			q.push(ele);
			bfs_dist[ele] = 0;
		}

		while(!q.empty()){
			ll u = q.front();
			q.pop();
			for(ll v: g[u]){
				if(bfs_dist[v] > bfs_dist[u] + 1){
					bfs_dist[v] = bfs_dist[u] + 1;
					q.push(v);
				}
			}
		}
	}

	void dfs(ll u, ll p = -1){
		dbg(u, p);
		if(p == -1){
			depth.resize(n + 1, -1);
			depth[u] = 0;
		}else{
			depth[u] = 1 + depth[p];
		}

		for(ll v: g[u]){
			if(depth[v] == -1){
				dfs(v, u);
			}
		}
	}

	void dijkstra(vt<ll> src){
		dijkstra_dist.resize(n + 1, INF);
		mnpq<pair<ll, ll>> pq;
		for(ll ele: src){
			pq.push({0, ele});
			dijkstra_dist[ele] = 0;
		}
		while(!pq.empty()){
			pair<ll, ll> ele = pq.top();
			pq.pop();
		}
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>graph</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
