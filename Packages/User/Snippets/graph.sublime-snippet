<snippet>
	<content><![CDATA[

class graph{
public:
    int n, e;
    vector<vector<int>> g;
    vector<int> depth, parent;
    vector<bool> visited;
    int index = 0, n_;      // index = 1 for 1-based indexing

    graph(int _n, int _index = 0) {
        n = _n;
        index = _index;
        n_ = n + index;
        g.resize(n_);
        visited.assign(n_, false);
        parent.assign(n_, -1);
        depth.assign(n_, -1);
    }

    graph(int _n, vector<vector<int>> edge) : graph(_n) {
        g = edge;
    }

    void readGraph(int m) {
        for (int i = 0, u, v; i < m; i++) {
            cin >> u >> v;
            u -= 1 - index; v -= 1 - index;
            uadd(u, v);
        }
        // dbg(g);
    }

    // undirected edge
    void uadd(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    // directed edge
    void dadd(int u, int v) {
        g[u].push_back(v);
    }

    void bfs(int src) {
        queue<int> q;
        q.push(src);
        depth[src] = 0;
        visited[src] = true;

        while(!q.empty()) {
            int v = q.front();
            q.pop();

            for(int u: g[v]){
                if (visited[u])
                    continue;
                visited[u] = true;

                depth[u] = depth[v] + 1;
                parent[u] = v;
                q.push(u);
            }
        }
    }

    void dfs(int v, int w = -1) {
        if (w == -1)
            depth[v] = 0;
        visited[v] = true;

        for(int u: g[v]) {
            if(visited[u])
                continue;

            depth[u] = depth[v] + 1;
            parent[u] = v;
            dfs(u, v);
        }
    }
};

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>graph</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
